"""
Abstract Strategy Base Class
Provides the pluggable interface for all trading strategies in the Quant Hub system.

This base class defines the standardized lifecycle, risk management, and monitoring
interface that all strategies must implement. It integrates with the order management
system, risk controls, and performance tracking.
"""

import asyncio
from abc import ABC, abstractmethod
from datetime import datetime, timedelta
from decimal import Decimal
from enum import Enum
from typing import Optional, Dict, Any, List, Tuple, Union
from dataclasses import dataclass
import uuid
import hashlib
import json

from app.core.logging import get_logger
from app.db.models.strategy import Strategy as StrategyModel, StrategyStatus
from app.db.models.trade import Trade
from app.db.models.position import Position


logger = get_logger(__name__)


class SignalType(str, Enum):
    """Trading signal types"""
    BUY = "buy"
    SELL = "sell"
    EXIT = "exit"
    SCALE_IN = "scale_in"
    SCALE_OUT = "scale_out"


class SignalStrength(str, Enum):
    """Signal strength levels"""
    WEAK = "weak"
    MEDIUM = "medium"
    STRONG = "strong"
    CRITICAL = "critical"


@dataclass
class MarketData:
    """Market data snapshot for strategy processing"""
    symbol: str
    ltp: Decimal
    volume: int
    open_interest: int
    bid: Optional[Decimal] = None
    ask: Optional[Decimal] = None
    bid_qty: Optional[int] = None
    ask_qty: Optional[int] = None
    delta: Optional[Decimal] = None
    gamma: Optional[Decimal] = None
    theta: Optional[Decimal] = None
    vega: Optional[Decimal] = None
    iv: Optional[Decimal] = None
    timestamp: datetime = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.utcnow()


@dataclass
class TradingSignal:
    """Trading signal generated by strategy"""
    signal_id: str
    strategy_name: str
    signal_type: SignalType
    symbol: str
    quantity: int
    price: Optional[Decimal] = None
    strength: SignalStrength = SignalStrength.MEDIUM
    confidence: Optional[Decimal] = None  # 0.0 to 1.0
    hedge_symbol: Optional[str] = None
    hedge_quantity: Optional[int] = None
    hedge_price: Optional[Decimal] = None
    stop_loss: Optional[Decimal] = None
    profit_target: Optional[Decimal] = None
    timeout_minutes: Optional[int] = None
    metadata: Optional[Dict[str, Any]] = None
    created_at: datetime = None
    decision_hash: Optional[str] = None
    
    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.utcnow()
        if self.signal_id is None:
            self.signal_id = str(uuid.uuid4())
        if self.decision_hash is None:
            self.decision_hash = self.generate_decision_hash()
    
    def generate_decision_hash(self) -> str:
        """Generate audit-compliant decision hash"""
        hash_data = {
            'strategy': self.strategy_name,
            'signal_type': self.signal_type,
            'symbol': self.symbol,
            'quantity': float(self.quantity),
            'timestamp': self.created_at.isoformat(),
            'metadata': self.metadata or {}
        }
        hash_string = json.dumps(hash_data, sort_keys=True)
        return hashlib.sha256(hash_string.encode()).hexdigest()


@dataclass
class StrategyState:
    """Current state of strategy execution"""
    is_active: bool = False
    is_trading: bool = False
    positions_count: int = 0
    daily_pnl: Decimal = Decimal('0')
    unrealized_pnl: Decimal = Decimal('0')
    total_trades_today: int = 0
    consecutive_losses: int = 0
    last_trade_time: Optional[datetime] = None
    last_signal_time: Optional[datetime] = None
    circuit_breaker_active: bool = False
    risk_limit_reached: bool = False
    error_count: int = 0
    last_error: Optional[str] = None


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    
    Provides the pluggable interface with standardized lifecycle management,
    risk controls, performance tracking, and audit compliance.
    """
    
    def __init__(
        self,
        strategy_name: str,
        config: Dict[str, Any],
        db_session=None,
        redis_client=None,
        broker_client=None,
        risk_manager=None,
        order_manager=None
    ):
        self.strategy_name = strategy_name
        self.config = config
        self.db_session = db_session
        self.redis_client = redis_client
        self.broker_client = broker_client
        self.risk_manager = risk_manager
        self.order_manager = order_manager
        
        # Initialize state
        self.state = StrategyState()
        self.positions: Dict[str, Position] = {}
        self.active_signals: Dict[str, TradingSignal] = {}
        
        # Performance tracking
        self.start_time: Optional[datetime] = None
        self.metrics: Dict[str, Any] = {
            'signals_generated': 0,
            'trades_executed': 0,
            'trades_profitable': 0,
            'avg_latency_ms': 0,
            'total_pnl': Decimal('0'),
            'max_drawdown': Decimal('0'),
            'sharpe_ratio': None
        }
        
        # Risk controls
        self.daily_loss_limit = Decimal(str(config.get('daily_loss_limit', '25000')))
        self.max_position_size = config.get('max_position_size', 50)
        self.max_slippage_bps = config.get('max_slippage_bps', 30)  # 30 bps = â‚¹0.30
        
        logger.info(f"Strategy {self.strategy_name} initialized with config: {config}")
    
    # ==================== Abstract Methods ====================
    
    @abstractmethod
    async def initialize(self) -> bool:
        """
        Initialize strategy resources and prepare for trading.
        
        Returns:
            bool: True if initialization successful, False otherwise
        """
        pass
    
    @abstractmethod
    async def process_market_data(self, market_data: MarketData) -> Optional[TradingSignal]:
        """
        Process incoming market data and generate trading signals.
        
        Args:
            market_data: Latest market data snapshot
            
        Returns:
            Optional[TradingSignal]: Trading signal if generated, None otherwise
        """
        pass
    
    @abstractmethod
    async def on_trade_fill(self, trade: Trade) -> None:
        """
        Handle trade fill notification.
        
        Args:
            trade: Filled trade information
        """
        pass
    
    @abstractmethod
    async def on_position_update(self, position: Position) -> None:
        """
        Handle position update notification.
        
        Args:
            position: Updated position information
        """
        pass
    
    @abstractmethod
    def get_strategy_specific_config(self) -> Dict[str, Any]:
        """
        Get strategy-specific configuration parameters.
        
        Returns:
            Dict[str, Any]: Strategy configuration
        """
        pass
    
    @abstractmethod
    async def cleanup(self) -> None:
        """Clean up strategy resources on shutdown."""
        pass
    
    # ==================== Lifecycle Management ====================
    
    async def start(self) -> bool:
        """
        Start the strategy execution.
        
        Returns:
            bool: True if started successfully, False otherwise
        """
        try:
            logger.info(f"Starting strategy: {self.strategy_name}")
            
            # Initialize strategy
            if not await self.initialize():
                logger.error(f"Failed to initialize strategy: {self.strategy_name}")
                return False
            
            # Check risk limits
            if not await self._check_risk_limits():
                logger.warning(f"Risk limits prevent strategy start: {self.strategy_name}")
                return False
            
            # Mark as active
            self.state.is_active = True
            self.state.is_trading = True
            self.start_time = datetime.utcnow()
            
            # Update database
            await self._update_strategy_status(StrategyStatus.ACTIVE)
            
            logger.info(f"Strategy {self.strategy_name} started successfully")
            return True
            
        except Exception as e:
            logger.error(f"Error starting strategy {self.strategy_name}: {e}")
            await self._handle_error(f"Start failed: {e}")
            return False
    
    async def stop(self) -> bool:
        """
        Stop the strategy execution.
        
        Returns:
            bool: True if stopped successfully, False otherwise
        """
        try:
            logger.info(f"Stopping strategy: {self.strategy_name}")
            
            # Mark as inactive
            self.state.is_active = False
            self.state.is_trading = False
            
            # Cancel pending orders
            await self._cancel_pending_orders()
            
            # Update database
            await self._update_strategy_status(StrategyStatus.INACTIVE)
            
            # Cleanup resources
            await self.cleanup()
            
            logger.info(f"Strategy {self.strategy_name} stopped successfully")
            return True
            
        except Exception as e:
            logger.error(f"Error stopping strategy {self.strategy_name}: {e}")
            return False
    
    async def pause(self) -> bool:
        """
        Pause the strategy execution.
        
        Returns:
            bool: True if paused successfully, False otherwise
        """
        try:
            logger.info(f"Pausing strategy: {self.strategy_name}")
            
            self.state.is_trading = False
            await self._update_strategy_status(StrategyStatus.PAUSED)
            
            logger.info(f"Strategy {self.strategy_name} paused")
            return True
            
        except Exception as e:
            logger.error(f"Error pausing strategy {self.strategy_name}: {e}")
            return False
    
    async def resume(self) -> bool:
        """
        Resume the strategy execution.
        
        Returns:
            bool: True if resumed successfully, False otherwise
        """
        try:
            logger.info(f"Resuming strategy: {self.strategy_name}")
            
            # Check risk limits before resuming
            if not await self._check_risk_limits():
                logger.warning(f"Risk limits prevent strategy resume: {self.strategy_name}")
                return False
            
            self.state.is_trading = True
            await self._update_strategy_status(StrategyStatus.ACTIVE)
            
            logger.info(f"Strategy {self.strategy_name} resumed")
            return True
            
        except Exception as e:
            logger.error(f"Error resuming strategy {self.strategy_name}: {e}")
            return False
    
    # ==================== Signal Processing ====================
    
    async def generate_signal(self, market_data: MarketData) -> Optional[TradingSignal]:
        """
        Main signal generation entry point with risk checks and audit logging.
        
        Args:
            market_data: Market data to process
            
        Returns:
            Optional[TradingSignal]: Generated signal if valid, None otherwise
        """
        try:
            # Check if strategy is active and trading
            if not self.state.is_active or not self.state.is_trading:
                return None
            
            # Check risk limits
            if not await self._check_risk_limits():
                return None
            
            # Process market data
            signal = await self.process_market_data(market_data)
            
            if signal:
                # Validate signal
                if await self._validate_signal(signal):
                    # Store signal
                    self.active_signals[signal.signal_id] = signal
                    self.metrics['signals_generated'] += 1
                    self.state.last_signal_time = datetime.utcnow()
                    
                    # Log for audit
                    await self._log_signal_decision(signal, market_data)
                    
                    logger.info(f"Signal generated: {signal.signal_type} {signal.symbol} "
                              f"qty={signal.quantity} strength={signal.strength}")
                    
                    return signal
                else:
                    logger.warning(f"Signal validation failed for {signal.symbol}")
            
            return None
            
        except Exception as e:
            logger.error(f"Error generating signal: {e}")
            await self._handle_error(f"Signal generation error: {e}")
            return None
    
    # ==================== Risk Management ====================
    
    async def _check_risk_limits(self) -> bool:
        """Check if strategy can continue trading based on risk limits."""
        try:
            # Check daily loss limit
            if self.state.daily_pnl <= -self.daily_loss_limit:
                logger.warning(f"Daily loss limit reached: {self.state.daily_pnl}")
                self.state.risk_limit_reached = True
                await self._trigger_circuit_breaker("Daily loss limit exceeded")
                return False
            
            # Check position limits
            if self.state.positions_count >= self.max_position_size:
                logger.warning(f"Position limit reached: {self.state.positions_count}")
                return False
            
            # Check consecutive losses
            if self.state.consecutive_losses >= 5:
                logger.warning(f"Consecutive loss limit reached: {self.state.consecutive_losses}")
                await self._trigger_circuit_breaker("Excessive consecutive losses")
                return False
            
            # Check if circuit breaker is active
            if self.state.circuit_breaker_active:
                return False
            
            return True
            
        except Exception as e:
            logger.error(f"Error checking risk limits: {e}")
            return False
    
    async def _validate_signal(self, signal: TradingSignal) -> bool:
        """Validate trading signal before execution."""
        try:
            # Basic validation
            if not signal.symbol or signal.quantity <= 0:
                return False
            
            # Check position size limits
            current_position = self.positions.get(signal.symbol)
            if current_position:
                new_quantity = abs(current_position.quantity) + abs(signal.quantity)
                if new_quantity > self.max_position_size:
                    logger.warning(f"Signal would exceed position limit for {signal.symbol}")
                    return False
            
            # Strategy-specific validation can be overridden
            return True
            
        except Exception as e:
            logger.error(f"Error validating signal: {e}")
            return False
    
    async def _trigger_circuit_breaker(self, reason: str) -> None:
        """Trigger circuit breaker and halt trading."""
        try:
            logger.error(f"Circuit breaker triggered: {reason}")
            
            self.state.circuit_breaker_active = True
            self.state.is_trading = False
            
            # Update database
            await self._update_strategy_status(StrategyStatus.ERROR)
            
            # Cancel pending orders
            await self._cancel_pending_orders()
            
            # Notify risk manager
            if self.risk_manager:
                await self.risk_manager.handle_circuit_breaker(self.strategy_name, reason)
            
        except Exception as e:
            logger.error(f"Error triggering circuit breaker: {e}")
    
    # ==================== Performance Tracking ====================
    
    def update_performance_metrics(self, trade: Trade) -> None:
        """Update strategy performance metrics."""
        try:
            self.metrics['trades_executed'] += 1
            
            if trade.realized_pnl > 0:
                self.metrics['trades_profitable'] += 1
            
            # Update P&L
            self.metrics['total_pnl'] += trade.realized_pnl
            self.state.daily_pnl += trade.realized_pnl
            
            # Update consecutive losses
            if trade.realized_pnl < 0:
                self.state.consecutive_losses += 1
            else:
                self.state.consecutive_losses = 0
            
            # Calculate win rate
            if self.metrics['trades_executed'] > 0:
                win_rate = self.metrics['trades_profitable'] / self.metrics['trades_executed']
                self.metrics['win_rate'] = win_rate
            
            logger.debug(f"Performance updated - Total PnL: {self.metrics['total_pnl']}, "
                        f"Win Rate: {self.metrics.get('win_rate', 0):.2%}")
            
        except Exception as e:
            logger.error(f"Error updating performance metrics: {e}")
    
    def get_performance_summary(self) -> Dict[str, Any]:
        """Get current performance summary."""
        runtime_hours = 0
        if self.start_time:
            runtime_hours = (datetime.utcnow() - self.start_time).total_seconds() / 3600
        
        return {
            'strategy_name': self.strategy_name,
            'runtime_hours': round(runtime_hours, 2),
            'is_active': self.state.is_active,
            'is_trading': self.state.is_trading,
            'total_signals': self.metrics['signals_generated'],
            'total_trades': self.metrics['trades_executed'],
            'profitable_trades': self.metrics['trades_profitable'],
            'win_rate': self.metrics.get('win_rate', 0),
            'total_pnl': float(self.metrics['total_pnl']),
            'daily_pnl': float(self.state.daily_pnl),
            'positions_count': self.state.positions_count,
            'consecutive_losses': self.state.consecutive_losses,
            'circuit_breaker_active': self.state.circuit_breaker_active,
            'last_trade_time': self.state.last_trade_time.isoformat() if self.state.last_trade_time else None,
            'last_signal_time': self.state.last_signal_time.isoformat() if self.state.last_signal_time else None
        }
    
    # ==================== Utility Methods ====================
    
    async def _update_strategy_status(self, status: StrategyStatus) -> None:
        """Update strategy status in database."""
        try:
            if self.db_session:
                # This would update the Strategy model in database
                # Implementation depends on database session management
                pass
        except Exception as e:
            logger.error(f"Error updating strategy status: {e}")
    
    async def _cancel_pending_orders(self) -> None:
        """Cancel all pending orders for this strategy."""
        try:
            if self.order_manager:
                await self.order_manager.cancel_strategy_orders(self.strategy_name)
        except Exception as e:
            logger.error(f"Error canceling pending orders: {e}")
    
    async def _log_signal_decision(self, signal: TradingSignal, market_data: MarketData) -> None:
        """Log signal decision for audit compliance."""
        try:
            audit_data = {
                'strategy_name': self.strategy_name,
                'signal_id': signal.signal_id,
                'decision_hash': signal.decision_hash,
                'market_data_snapshot': {
                    'symbol': market_data.symbol,
                    'ltp': float(market_data.ltp),
                    'volume': market_data.volume,
                    'open_interest': market_data.open_interest,
                    'timestamp': market_data.timestamp.isoformat()
                },
                'signal_data': {
                    'type': signal.signal_type,
                    'symbol': signal.symbol,
                    'quantity': signal.quantity,
                    'strength': signal.strength,
                    'confidence': float(signal.confidence) if signal.confidence else None
                },
                'created_at': datetime.utcnow().isoformat()
            }
            
            # Store in Redis for fast access and database for persistence
            if self.redis_client:
                await self.redis_client.setex(
                    f"audit:signal:{signal.signal_id}",
                    86400,  # 24 hours
                    json.dumps(audit_data)
                )
            
            logger.debug(f"Signal decision logged for audit: {signal.signal_id}")
            
        except Exception as e:
            logger.error(f"Error logging signal decision: {e}")
    
    async def _handle_error(self, error_message: str) -> None:
        """Handle strategy errors and update state."""
        self.state.error_count += 1
        self.state.last_error = error_message
        
        # Trigger circuit breaker if too many errors
        if self.state.error_count >= 5:
            await self._trigger_circuit_breaker(f"Excessive errors: {error_message}")
    
    # ==================== Health Check ====================
    
    def get_health_status(self) -> Dict[str, Any]:
        """Get strategy health status."""
        return {
            'strategy_name': self.strategy_name,
            'status': 'healthy' if self.state.is_active and not self.state.circuit_breaker_active else 'unhealthy',
            'is_active': self.state.is_active,
            'is_trading': self.state.is_trading,
            'circuit_breaker_active': self.state.circuit_breaker_active,
            'error_count': self.state.error_count,
            'last_error': self.state.last_error,
            'consecutive_losses': self.state.consecutive_losses,
            'daily_pnl': float(self.state.daily_pnl),
            'positions_count': self.state.positions_count,
            'uptime_seconds': (datetime.utcnow() - self.start_time).total_seconds() if self.start_time else 0
        } 